<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed"><link rel="stylesheet" href="/css/style.css" type="text/css">

		

		<link rel="stylesheet" href="/_app/assets/start-61d1577b.css">
		<link rel="stylesheet" href="/_app/assets/pages/__layout.svelte-67097d95.css">

		
	</head>
	<body>
		<div id="svelte">




<header><nav role="navigation" class="navbar svelte-d1vz7p"><a class="nav-link svelte-d1vz7p" href="/">Home</a>
		<ul class="svelte-d1vz7p">
			<li class="svelte-d1vz7p"><a href="/blog/" class="nav-link svelte-d1vz7p">Articles</a></li>
			
			<li class="svelte-d1vz7p"><a href="/about" class="nav-link svelte-d1vz7p">About</a></li></ul></nav>
</header>

<main class="main"><div class="content"><article class="post"><header><h1>Async/Await with Generators and Promises</h1>
		<span class="post-date">November 15, 2017</span></header>
	<h2>Javascript Generator Series</h2>
<p>This article is part of a series of articles about ES6 generators. The plan is to explore iterators and generators, starting with what they are and show casing different situations where they can be useful.</p>
<ol><li><a href="/blog/intro-to-es6-iter-and-generators">Introduction to ES6 Iterators and Generators</a></li>
<li><a href="/blog/working-with-generators">Working with Generators</a></li>
<li>Async/Await with Generators</li></ol>
<h2>Introduction</h2>
<p>Generators are not only useful for generating a stream of values but can also be a powerful control structure when paired with an external runner. In this article we will take a stab at implementing <code>async</code>/<code>await</code> using only ES6 tools (they have later been added and are part of ES7).</p>
<p>For anyone unfamiliar with <code>async</code>/<code>await</code>, this is how it looks in practice.</p>
<div class="highlighter-rouge language-javascript"><div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myAsync</span>(<span class="hljs-params">input</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> res1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">anAsynchronousOperation</span>(input)
    <span class="hljs-keyword">const</span> res2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">anotherAsync</span>(res1)
    <span class="hljs-keyword">return</span> res2
  }
  <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// handle the error</span>
  }
}

<span class="hljs-title function_">myAsync</span>(<span class="hljs-number">123</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-comment">//...)</span></code></pre></div></div>
<p>The benefit is that your programming style is very sequencial even though the code is not blocking the event loop.</p>
<p>Since we canâ€™t use the special syntax that <code>async</code>/<code>await</code> introduces our code will looks slightly different but with the same semantics.</p>
<div class="highlighter-rouge language-javascript"><div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">const</span> myAsync = <span class="hljs-title function_">makeAsync</span>(<span class="hljs-keyword">function</span>* (input) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> res1 = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">anAsynchronousOperation</span>(input)
    <span class="hljs-keyword">const</span> res2 = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">anotherAsync</span>(res1)
    <span class="hljs-keyword">return</span> res2
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// handle the error</span>
  }
})

<span class="hljs-title function_">myAsync</span>(<span class="hljs-number">123</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-comment">//...)</span></code></pre></div></div>
<p>The difference is that <code>makeAsync</code> is now a function instead of a keyword and that <code>await</code> has been replaced with <code>yield</code>.</p>
<h2>Passing values into the generator</h2>
<p>As can be seen in the example above, the generator code gets a value back from calling <code>yield</code>. In the previous articles <code>yield</code> was used to pass values out of the generator. In order to send values into the generator (as return values from <code>yield</code>) we pass a value with the <code>next()</code> method.</p>
<p>We can use this to pass the values of a promise resolution back into the generator once the promise is resolved. In the same way we can use <code>throw()</code> on the iterator to throw an exception in the context of the generator.</p>
<div class="highlighter-rouge language-javascript"><div class="highlight"><pre class="highlight"><code><span class="hljs-comment">// return a value from yield</span>
iter.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#39;a value&#39;</span>)

<span class="hljs-comment">// throw an exception in the context of the yield call</span>
iter.<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#39;Exception&#39;</span>))</code></pre></div></div>
<p>With this knowledge we can set out to implement our <code>makeAsync</code> function!</p>
<h2>Implementing makeAsync</h2>
<p>The <code>makeAsync</code> function itself is fairly simple. It wraps the passed generator in a function that takes the arguments (<code>input</code> in our example above) and pass them into the generator when called.</p>
<div class="highlighter-rouge language-javascript"><div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeAsync</span>(<span class="hljs-params">generator</span>) {
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
		<span class="hljs-keyword">const</span> gen = <span class="hljs-title function_">generator</span>(...args)
		<span class="hljs-keyword">return</span> <span class="hljs-title function_">iterateAsync</span>(gen, gen.<span class="hljs-title function_">next</span>())
	}
}</code></pre></div></div>
<p>The interesting work will be done in the <code>iterateAsync</code> function that will be called recursively to step through the generator until the generator is done. <code>iterateAsync</code> returns a promise that will be resolved once the generator is done.</p>
<p>Here is the resulting code:</p>
<div class="highlighter-rouge language-javascript"><div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">iterateAsync</span>(<span class="hljs-params">gen, { value, done }</span>) {
  <span class="hljs-keyword">if</span> (done) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(value)
  }

  <span class="hljs-comment">// If the value is not a promise (for example &#39;yield 123&#39;), wrap it in one.</span>
  <span class="hljs-keyword">const</span> promise = value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span> ? value : <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(value)
  <span class="hljs-keyword">return</span> promise
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">iterateAsync</span>(gen, gen.<span class="hljs-title function_">next</span>(result)))
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title function_">iterateAsync</span>(gen, gen.<span class="hljs-keyword">throw</span>(error)))
  })
}</code></pre></div></div>
<h3>Caveat</h3>
<p>As far as my testing went, this behaves exactly as async/await with one little caveat.</p>
<div class="highlighter-rouge language-javascript"><div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">const</span> resultGen = <span class="hljs-keyword">yield</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>) + <span class="hljs-number">100</span>
<span class="hljs-keyword">const</span> resultAsync = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>) + <span class="hljs-number">100</span>
<span class="hljs-comment">// resultGen = &quot;[object Promise]100&quot;</span>
<span class="hljs-comment">// resultAsync = 200</span></code></pre></div></div>
<p>In the case of <code>yield</code>, Javascript first evaluates <code>Promise.resolve(100) + 100</code> which it does by converting both to strings and then sends that to <code>yield</code>. The solution to this is to wrap it in parenthesis.</p>
<div class="highlighter-rouge language-javascript"><div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">const</span> resultGen = (<span class="hljs-keyword">yield</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>)) + <span class="hljs-number">100</span>
<span class="hljs-comment">// resultGen = 200</span></code></pre></div></div>
<h2>Summary</h2>
<p>This article covered using generators and promises to implement async/await which is available in ES7. The main reason for doing this was to learn more about how to work with generators.</p>
<p>The code can be found at: <a href="https://github.com/hallski/es6-async" rel="nofollow">https://github.com/hallski/es6-async</a></p>
<p>While finishing up this article I was looking around for a proper implementation of this as it can be quite useful with Node 6.11 (which is still the version used by Google Cloud Functions) I stumbled over an article series by Kyle Simpson.</p>
<p>His excellent talk <a href="https://www.youtube.com/watch?v=NNcT9ZehM6g" rel="nofollow">Coordinated Concurrency: Reactive (Observables) vs. CSP</a> at JS.LA in 2015 was the reason I started learning more about generators in the first place. And since the fourth article in his series <a href="https://davidwalsh.name/es6-generators" rel="nofollow">ES6 Generators: Complete Series</a> is about CSP with generators, which is what I had planned on writing about next, I suggest reading that instead.</p></article></div></main>

<footer class="site-footer svelte-1h9y0mo"><div class="author svelte-1h9y0mo"><img class="author-photo svelte-1h9y0mo" src="/images/hallski.jpg" width="192" height="192" alt="Author">
		<div><p class="author-name svelte-1h9y0mo">Mikael Hallendal</p>
			<p class="author-info svelte-1h9y0mo">Developer who loves to learn new things.</p>
			<p class="author-interests svelte-1h9y0mo">Current focus: <span class="interest svelte-1h9y0mo">React</span>,
				<span class="interest svelte-1h9y0mo">Javascript/Typescript</span> and
				<span class="interest svelte-1h9y0mo">Elixir</span></p>
			<nav class="find-me svelte-1h9y0mo"><a href="http://github.com/hallski/" class="svelte-1h9y0mo">Github</a>
				<a href="http://twitter.com/mhallendal/" class="svelte-1h9y0mo">Twitter</a>
				<a href="http://www.linkedin.com/in/mhallendal" class="svelte-1h9y0mo">LinkedIn</a></nav></div></div>
</footer>



			
		</div>
	</body>
</html>
