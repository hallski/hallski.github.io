import{S as Y,i as ee,s as se,y as K,r as te,u as ne,v as ae,w as V,m as le,k as oe,x as ie,I as X,e as a,g as o,a as F,c as t,n as re,f as n}from"./index-0d9ad2d2.js";import{B as pe}from"./blog-layout-f66b7ab1.js";function fe(d){let l,p,f,c,i,r,u,C,b,$,m,g,j,W,h,q,w,z,_,A,x,B,y,J,I,E,T,D,S,N,k,O,v,R,M,U,H,P,L,Z,G;return{c(){l=a("h2"),l.textContent="Javascript Generator Series",p=o(),f=a("p"),f.textContent="This article is part of a series of articles about ES6 generators. The plan is to explore iterators and generators, starting with what they are and show casing different situations where they can be useful.",c=o(),i=a("ol"),i.innerHTML=`<li>Introduction to ES6 Iterators and Generators</li> 
<li><a href="/blog/working-with-generators">Working with Generators</a></li> 
<li><a href="/blog/async-await-with-generators">Async/Await with Generators</a></li>`,r=o(),u=a("h2"),u.textContent="Iterator basics",C=o(),b=a("p"),b.innerHTML="Iterators in Javascript are objects that implement <code>next()</code> which returns an object with two properties, <code>done</code> and <code>value</code>.",$=o(),m=a("div"),m.innerHTML=`<div class="highlight"><pre class="highlight"><code><span class="hljs-comment">// Simple Iterator</span>
{
	<span class="hljs-attr">next</span>: <span class="hljs-function">() =&gt;</span> ({ <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> })
}</code></pre></div>`,g=o(),j=a("p"),j.innerHTML="An <em>Iterable</em> is an object that can be iterated over, the informal protocol for an Iterable is an object that defines the <code>Symbol.iterable</code> method which returns an iterator.",W=o(),h=a("div"),h.innerHTML=`<div class="highlight"><pre class="highlight"><code><span class="hljs-comment">// Simple Iterable</span>
{
  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]: <span class="hljs-function">() =&gt;</span> ({ <span class="hljs-attr">next</span>: <span class="hljs-function">() =&gt;</span> ({ <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> })})
}</code></pre></div>`,q=o(),w=a("p"),w.innerHTML="These aren\u2019t very useful since all they do is return an infinite stream of the number <code>1</code> when iterated over.",z=o(),_=a("p"),_.innerHTML='By conforming to the <em>Iterable</em> protocol an object can be used in the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="nofollow"><code>for...of</code></a> construct.',A=o(),x=a("h2"),x.textContent="Generator Basics",B=o(),y=a("p"),y.innerHTML="So, what do <em>Iterator</em> and <em>Iterable</em> have to do with <em>Generators</em>? Turns out, a lot, since Generators conform to both <em>Iterable</em> and <em>Iterator</em>.",J=o(),I=a("p"),I.innerHTML='In short, generators are <a href="https://en.wikipedia.org/wiki/Coroutine" rel="nofollow">coroutines</a>. Here is the short description from MDN:',E=o(),T=a("blockquote"),T.innerHTML="<p>Generators are functions which can be exited and later re-entered. Their context (variable bindings) will be saved across re-entrances.</p>",D=o(),S=a("p"),S.innerHTML="When the generator is iterated over, through <code>next()</code>, it executes to the first <code>yield</code> statement. There it will save it\u2019s state and return the value passed to yield. The next time <code>next()</code> is called, the state will be restored and the code will continue executing where it left of. This will continue until the end of the function (or <code>return</code>) where the final value will be returned and the iterator marked as <code>done</code>.",N=o(),k=a("p"),k.innerHTML="A function is declared a generator by adding an <code>*</code> after the keyword <code>function</code>.",O=o(),v=a("div"),v.innerHTML=`<div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">aGenerator</span>(<span class="hljs-params"></span>) {
	<span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
	<span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
	<span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">4</span>
}

<span class="hljs-keyword">const</span> gen = <span class="hljs-title function_">aGenerator</span>()
gen.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// { value: 1, done: false }</span>
gen.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// { value: 2, done: false }</span>
gen.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// { value: 3, done: false }</span>
gen.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// { value: 4, done: true }</span></code></pre></div>`,R=o(),M=a("p"),M.innerHTML='See MDN for more in-depth information about <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="nofollow">generator functions</a>.',U=o(),H=a("h2"),H.textContent="Why are generators interesting",P=o(),L=a("p"),L.textContent="In the next couple of articles, we\u2019ll have a look on various use cases for generators. Starting with infinite generators that generate an infinite stream of values and show how they can be useful in the context of a finite iteration.",Z=o(),G=a("p"),G.textContent="In the later articles, we\u2019ll look at more advanced use cases, where we pass values into the generator and even use them for synchronization when doing concurrent programming.",F(m,"class","highlighter-rouge language-javascript"),F(h,"class","highlighter-rouge language-javascript"),F(v,"class","highlighter-rouge language-javascript")},m(e,s){t(e,l,s),t(e,p,s),t(e,f,s),t(e,c,s),t(e,i,s),t(e,r,s),t(e,u,s),t(e,C,s),t(e,b,s),t(e,$,s),t(e,m,s),t(e,g,s),t(e,j,s),t(e,W,s),t(e,h,s),t(e,q,s),t(e,w,s),t(e,z,s),t(e,_,s),t(e,A,s),t(e,x,s),t(e,B,s),t(e,y,s),t(e,J,s),t(e,I,s),t(e,E,s),t(e,T,s),t(e,D,s),t(e,S,s),t(e,N,s),t(e,k,s),t(e,O,s),t(e,v,s),t(e,R,s),t(e,M,s),t(e,U,s),t(e,H,s),t(e,P,s),t(e,L,s),t(e,Z,s),t(e,G,s)},p:re,d(e){e&&n(l),e&&n(p),e&&n(f),e&&n(c),e&&n(i),e&&n(r),e&&n(u),e&&n(C),e&&n(b),e&&n($),e&&n(m),e&&n(g),e&&n(j),e&&n(W),e&&n(h),e&&n(q),e&&n(w),e&&n(z),e&&n(_),e&&n(A),e&&n(x),e&&n(B),e&&n(y),e&&n(J),e&&n(I),e&&n(E),e&&n(T),e&&n(D),e&&n(S),e&&n(N),e&&n(k),e&&n(O),e&&n(v),e&&n(R),e&&n(M),e&&n(U),e&&n(H),e&&n(P),e&&n(L),e&&n(Z),e&&n(G)}}}function ce(d){let l,p;const f=[d[0],Q];let c={$$slots:{default:[fe]},$$scope:{ctx:d}};for(let i=0;i<f.length;i+=1)c=K(c,f[i]);return l=new pe({props:c}),{c(){te(l.$$.fragment)},m(i,r){ne(l,i,r),p=!0},p(i,[r]){const u=r&1?ae(f,[r&1&&V(i[0]),r&0&&V(Q)]):{};r&2&&(u.$$scope={dirty:r,ctx:i}),l.$set(u)},i(i){p||(le(l.$$.fragment,i),p=!0)},o(i){oe(l.$$.fragment,i),p=!1},d(i){ie(l,i)}}}const Q={comments:!0,date:"2017-11-13T00:00:00Z",excerpt:"In this first article about generators we'll have a quick look at the basics of Iterator, Iterable and Generators.",section:"blog",tags:["javascript","generators","es6"],title:"Introduction to ES6 Iterators and Generators"};function ue(d,l,p){return d.$$set=f=>{p(0,l=K(K({},l),X(f)))},l=X(l),[l]}class de extends Y{constructor(l){super(),ee(this,l,ue,ce,se,{})}}var ve=Object.freeze(Object.defineProperty({__proto__:null,default:de,metadata:Q},Symbol.toStringTag,{value:"Module"}));export{de as I,ve as _,Q as m};
