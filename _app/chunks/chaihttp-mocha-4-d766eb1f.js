import{S as C,i as I,s as $,y as x,r as L,u as P,v as S,w as H,m as A,k as B,x as N,I as M,e as r,g as h,a as k,c as n,n as O,f as l}from"./index-0d9ad2d2.js";import{B as z}from"./blog-layout-f66b7ab1.js";function U(f){let t,p,i,u,e,o,c,v,m,w,_,y,g,b,d,T,j;return{c(){t=r("p"),t.innerHTML='<a href="http://chaijs.com/plugins/chai-http/" rel="nofollow">Chai-http</a> makes it very easy to test Node.js HTTP applications without having to to go through the hassle of finding a free port and start the service manually. By simply passing the server function to the <code>request</code> call it will take care of that for you.',p=h(),i=r("div"),i.innerHTML=`<div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">const</span> chai = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;chai&#39;</span>)
<span class="hljs-keyword">const</span> chaiHttp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;chai-http&#39;</span>)
<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;express&#39;</span>)

chai.<span class="hljs-title function_">use</span>(chaiHttp)

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()
<span class="hljs-comment">// configure app with middleware and routes...</span>

chai
	.<span class="hljs-title function_">request</span>(app)
	.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#39;/&#39;</span>)
	.<span class="hljs-title function_">end</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error, result</span>) {
		<span class="hljs-comment">// Verify error and result</span>
	})</code></pre></div>`,u=h(),e=r("p"),e.innerHTML='At first I thought it simulated HTTP requests by generating the request/response objects and passing them to the handler function directly. However it seems Chai-http actually finds a free port, starts the service as normal and uses <a href="https://github.com/visionmedia/superagent" rel="nofollow">Superagent</a> to send HTTP requests against it.',o=h(),c=r("p"),c.textContent="This lead to an issue when switching to Mocha 4.",v=h(),m=r("h2"),m.textContent="Mocha 4 changed exit behaviour",w=h(),_=r("p"),_.textContent="As I started a new project the other day I ran into a problem where the test runner never finishes and initially thought I had messed up my tests. After some investigation it seemed like Node.js never exits the event loop due to the HTTP server still listening to the socket.",y=h(),g=r("p"),g.innerHTML="It turns out that Mocha 4 changed the default exit behaviour to no longer force shutdown the event loop after all tests ran. Using the <code>--exit</code> flags brings back the old behaviour which Chai-http is relying on to shutdown the HTTP server it started.",b=h(),d=r("div"),d.innerHTML=`<div class="highlight"><pre class="highlight"><code>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha --exit&quot;</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span></code></pre></div>`,T=h(),j=r("p"),j.innerHTML='This solves the problem but as discussed in <a href="https://github.com/chaijs/chai-http/issues/178" rel="nofollow">Issue #178</a>, a better long term solution would be to get more control over the server instance and shut it down when appropriate from the test code.',k(i,"class","highlighter-rouge language-javascript"),k(d,"class","highlighter-rouge language-json")},m(s,a){n(s,t,a),n(s,p,a),n(s,i,a),n(s,u,a),n(s,e,a),n(s,o,a),n(s,c,a),n(s,v,a),n(s,m,a),n(s,w,a),n(s,_,a),n(s,y,a),n(s,g,a),n(s,b,a),n(s,d,a),n(s,T,a),n(s,j,a)},p:O,d(s){s&&l(t),s&&l(p),s&&l(i),s&&l(u),s&&l(e),s&&l(o),s&&l(c),s&&l(v),s&&l(m),s&&l(w),s&&l(_),s&&l(y),s&&l(g),s&&l(b),s&&l(d),s&&l(T),s&&l(j)}}}function V(f){let t,p;const i=[f[0],q];let u={$$slots:{default:[U]},$$scope:{ctx:f}};for(let e=0;e<i.length;e+=1)u=x(u,i[e]);return t=new z({props:u}),{c(){L(t.$$.fragment)},m(e,o){P(t,e,o),p=!0},p(e,[o]){const c=o&1?S(i,[o&1&&H(e[0]),o&0&&H(q)]):{};o&2&&(c.$$scope={dirty:o,ctx:e}),t.$set(c)},i(e){p||(A(t.$$.fragment,e),p=!0)},o(e){B(t.$$.fragment,e),p=!1},d(e){N(t,e)}}}const q={comments:!0,date:"2017-10-28T00:00:00Z",excerpt:"With Mocha 4, tests using Chai-http will cause the test run to never exit.",section:"blog",tags:["javascript","testing"],title:"Testing with chai-http and Mocha 4"};function W(f,t,p){return f.$$set=i=>{p(0,t=x(x({},t),M(i)))},t=M(t),[t]}class Z extends C{constructor(t){super(),I(this,t,W,V,$,{})}}var F=Object.freeze(Object.defineProperty({__proto__:null,default:Z,metadata:q},Symbol.toStringTag,{value:"Module"}));export{Z as C,F as _,q as m};
