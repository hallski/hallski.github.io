import{S as H,i as M,s as S,w as g,f as L,m as $,j as O,k as T,q as J,n as U,o as q,P as x,e as c,g as u,a as C,b as n,d as a}from"./vendor-e167c7c5.js";import{B as A}from"./blog-layout-233a6880.js";function B(f){let s,r,l,p,t,i,d,j,_,y,w,v,h,b,m;return{c(){s=c("p"),s.innerHTML="One of the things that confused me most when starting out with Javascript was <em>constructor</em> functions. That\u2019s because when used together with <code>new</code> they look like a normal class in other langues.",r=u(),l=c("div"),l.innerHTML='<div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Constructor</span>()</code></pre></div>',p=u(),t=c("p"),t.innerHTML="However, they can also be called without the <code>new</code> keyword which will lead to <code>this</code> pointing to the global object instead. The new ES6 <code>class</code> keyword fixes that by throwing an exception when called without <code>new</code>.",i=u(),d=c("p"),d.innerHTML="So what does <code>new</code> do anyway?",j=u(),_=c("p"),_.innerHTML="After some research it seems we can simply implement our own <code>new</code> as a function like this:",y=u(),w=c("div"),w.innerHTML=`<div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">constructor, ...args</span>) {
	<span class="hljs-keyword">const</span> newObj = {}
	newObj.<span class="hljs-property">__proto__</span> = constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
	<span class="hljs-keyword">const</span> fromConstructor = constructor.<span class="hljs-title function_">apply</span>(newObj, args)
	<span class="hljs-keyword">if</span> (fromConstructor) {
		<span class="hljs-keyword">return</span> fromConstructor
	}
	<span class="hljs-keyword">return</span> newObj
}</code></pre></div>`,v=u(),h=c("p"),h.textContent="New is simply responsible for:",b=u(),m=c("ol"),m.innerHTML=`<li>Creating a new object</li> 
<li>Set it\u2019s prototype to that of the constructors <code>prototype</code> property</li> 
<li>Call the constructor with <code>this</code> bound to the newly created object.</li> 
<li>As constructors in Javascript are allowed to return a different object, <code>new</code> also needs to check if it did and return that instead when that\u2019s the case.</li>`,C(l,"class","highlighter-rouge language-javascript"),C(w,"class","highlighter-rouge language-javascript")},m(e,o){n(e,s,o),n(e,r,o),n(e,l,o),n(e,p,o),n(e,t,o),n(e,i,o),n(e,d,o),n(e,j,o),n(e,_,o),n(e,y,o),n(e,w,o),n(e,v,o),n(e,h,o),n(e,b,o),n(e,m,o)},d(e){e&&a(s),e&&a(r),e&&a(l),e&&a(p),e&&a(t),e&&a(i),e&&a(d),e&&a(j),e&&a(_),e&&a(y),e&&a(w),e&&a(v),e&&a(h),e&&a(b),e&&a(m)}}}function N(f){let s,r;const l=[f[0],k];let p={$$slots:{default:[B]},$$scope:{ctx:f}};for(let t=0;t<l.length;t+=1)p=g(p,l[t]);return s=new A({props:p}),{c(){L(s.$$.fragment)},m(t,i){$(s,t,i),r=!0},p(t,[i]){const d=i&1?O(l,[i&1&&T(t[0]),i&0&&T(k)]):{};i&2&&(d.$$scope={dirty:i,ctx:t}),s.$set(d)},i(t){r||(J(s.$$.fragment,t),r=!0)},o(t){U(s.$$.fragment,t),r=!1},d(t){q(s,t)}}}const k={comments:null,date:"2017-09-20T00:00:00Z",section:"blog",tags:["javascript"],title:"Understanding 'new' in JS"};function z(f,s,r){return f.$$set=l=>{r(0,s=g(g({},s),x(l)))},s=x(s),[s]}class E extends H{constructor(s){super();M(this,s,z,N,S,{})}}var D=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",default:E,metadata:k});export{E as U,D as _,k as m};
