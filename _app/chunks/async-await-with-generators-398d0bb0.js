import{S as ks,i as bs,s as gs,y as ys,r as xs,u as Ts,v as As,w as vs,m as Hs,k as Ms,x as Ls,I as _s,e as a,g as l,a as f,c as n,n as Cs,f as t}from"./index-0d9ad2d2.js";import{B as Ss}from"./blog-layout-f66b7ab1.js";function Is(d){let i,r,c,h,o,p,u,F,b,Z,g,z,m,K,x,R,T,D,w,Q,A,U,H,V,M,X,L,Y,y,ss,C,es,S,ns,I,ts,j,as,P,ls,G,is,v,os,E,ps,$,rs,_,cs,q,hs,k,us,O,fs,W,ds,J,ms,N,ws,B;return{c(){i=a("h2"),i.textContent="Javascript Generator Series",r=l(),c=a("p"),c.textContent="This article is part of a series of articles about ES6 generators. The plan is to explore iterators and generators, starting with what they are and show casing different situations where they can be useful.",h=l(),o=a("ol"),o.innerHTML=`<li><a href="/blog/intro-to-es6-iter-and-generators">Introduction to ES6 Iterators and Generators</a></li> 
<li><a href="/blog/working-with-generators">Working with Generators</a></li> 
<li>Async/Await with Generators</li>`,p=l(),u=a("h2"),u.textContent="Introduction",F=l(),b=a("p"),b.innerHTML="Generators are not only useful for generating a stream of values but can also be a powerful control structure when paired with an external runner. In this article we will take a stab at implementing <code>async</code>/<code>await</code> using only ES6 tools (they have later been added and are part of ES7).",Z=l(),g=a("p"),g.innerHTML="For anyone unfamiliar with <code>async</code>/<code>await</code>, this is how it looks in practice.",z=l(),m=a("div"),m.innerHTML=`<div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myAsync</span>(<span class="hljs-params">input</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> res1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">anAsynchronousOperation</span>(input)
    <span class="hljs-keyword">const</span> res2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">anotherAsync</span>(res1)
    <span class="hljs-keyword">return</span> res2
  }
  <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// handle the error</span>
  }
}

<span class="hljs-title function_">myAsync</span>(<span class="hljs-number">123</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-comment">//...)</span></code></pre></div>`,K=l(),x=a("p"),x.textContent="The benefit is that your programming style is very sequencial even though the code is not blocking the event loop.",R=l(),T=a("p"),T.innerHTML="Since we can\u2019t use the special syntax that <code>async</code>/<code>await</code> introduces our code will looks slightly different but with the same semantics.",D=l(),w=a("div"),w.innerHTML=`<div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">const</span> myAsync = <span class="hljs-title function_">makeAsync</span>(<span class="hljs-keyword">function</span>* (input) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> res1 = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">anAsynchronousOperation</span>(input)
    <span class="hljs-keyword">const</span> res2 = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">anotherAsync</span>(res1)
    <span class="hljs-keyword">return</span> res2
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// handle the error</span>
  }
})

<span class="hljs-title function_">myAsync</span>(<span class="hljs-number">123</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-comment">//...)</span></code></pre></div>`,Q=l(),A=a("p"),A.innerHTML="The difference is that <code>makeAsync</code> is now a function instead of a keyword and that <code>await</code> has been replaced with <code>yield</code>.",U=l(),H=a("h2"),H.textContent="Passing values into the generator",V=l(),M=a("p"),M.innerHTML="As can be seen in the example above, the generator code gets a value back from calling <code>yield</code>. In the previous articles <code>yield</code> was used to pass values out of the generator. In order to send values into the generator (as return values from <code>yield</code>) we pass a value with the <code>next()</code> method.",X=l(),L=a("p"),L.innerHTML="We can use this to pass the values of a promise resolution back into the generator once the promise is resolved. In the same way we can use <code>throw()</code> on the iterator to throw an exception in the context of the generator.",Y=l(),y=a("div"),y.innerHTML=`<div class="highlight"><pre class="highlight"><code><span class="hljs-comment">// return a value from yield</span>
iter.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#39;a value&#39;</span>)

<span class="hljs-comment">// throw an exception in the context of the yield call</span>
iter.<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#39;Exception&#39;</span>))</code></pre></div>`,ss=l(),C=a("p"),C.innerHTML="With this knowledge we can set out to implement our <code>makeAsync</code> function!",es=l(),S=a("h2"),S.textContent="Implementing makeAsync",ns=l(),I=a("p"),I.innerHTML="The <code>makeAsync</code> function itself is fairly simple. It wraps the passed generator in a function that takes the arguments (<code>input</code> in our example above) and pass them into the generator when called.",ts=l(),j=a("div"),j.innerHTML=`<div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeAsync</span>(<span class="hljs-params">generator</span>) {
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
		<span class="hljs-keyword">const</span> gen = <span class="hljs-title function_">generator</span>(...args)
		<span class="hljs-keyword">return</span> <span class="hljs-title function_">iterateAsync</span>(gen, gen.<span class="hljs-title function_">next</span>())
	}
}</code></pre></div>`,as=l(),P=a("p"),P.innerHTML="The interesting work will be done in the <code>iterateAsync</code> function that will be called recursively to step through the generator until the generator is done. <code>iterateAsync</code> returns a promise that will be resolved once the generator is done.",ls=l(),G=a("p"),G.textContent="Here is the resulting code:",is=l(),v=a("div"),v.innerHTML=`<div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">iterateAsync</span>(<span class="hljs-params">gen, { value, done }</span>) {
  <span class="hljs-keyword">if</span> (done) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(value)
  }

  <span class="hljs-comment">// If the value is not a promise (for example &#39;yield 123&#39;), wrap it in one.</span>
  <span class="hljs-keyword">const</span> promise = value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span> ? value : <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(value)
  <span class="hljs-keyword">return</span> promise
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">iterateAsync</span>(gen, gen.<span class="hljs-title function_">next</span>(result)))
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title function_">iterateAsync</span>(gen, gen.<span class="hljs-keyword">throw</span>(error)))
  })
}</code></pre></div>`,os=l(),E=a("h3"),E.textContent="Caveat",ps=l(),$=a("p"),$.textContent="As far as my testing went, this behaves exactly as async/await with one little caveat.",rs=l(),_=a("div"),_.innerHTML=`<div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">const</span> resultGen = <span class="hljs-keyword">yield</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>) + <span class="hljs-number">100</span>
<span class="hljs-keyword">const</span> resultAsync = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>) + <span class="hljs-number">100</span>
<span class="hljs-comment">// resultGen = &quot;[object Promise]100&quot;</span>
<span class="hljs-comment">// resultAsync = 200</span></code></pre></div>`,cs=l(),q=a("p"),q.innerHTML="In the case of <code>yield</code>, Javascript first evaluates <code>Promise.resolve(100) + 100</code> which it does by converting both to strings and then sends that to <code>yield</code>. The solution to this is to wrap it in parenthesis.",hs=l(),k=a("div"),k.innerHTML=`<div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">const</span> resultGen = (<span class="hljs-keyword">yield</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>)) + <span class="hljs-number">100</span>
<span class="hljs-comment">// resultGen = 200</span></code></pre></div>`,us=l(),O=a("h2"),O.textContent="Summary",fs=l(),W=a("p"),W.textContent="This article covered using generators and promises to implement async/await which is available in ES7. The main reason for doing this was to learn more about how to work with generators.",ds=l(),J=a("p"),J.innerHTML='The code can be found at: <a href="https://github.com/hallski/es6-async" rel="nofollow">https://github.com/hallski/es6-async</a>',ms=l(),N=a("p"),N.textContent="While finishing up this article I was looking around for a proper implementation of this as it can be quite useful with Node 6.11 (which is still the version used by Google Cloud Functions) I stumbled over an article series by Kyle Simpson.",ws=l(),B=a("p"),B.innerHTML='His excellent talk <a href="https://www.youtube.com/watch?v=NNcT9ZehM6g" rel="nofollow">Coordinated Concurrency: Reactive (Observables) vs. CSP</a> at JS.LA in 2015 was the reason I started learning more about generators in the first place. And since the fourth article in his series <a href="https://davidwalsh.name/es6-generators" rel="nofollow">ES6 Generators: Complete Series</a> is about CSP with generators, which is what I had planned on writing about next, I suggest reading that instead.',f(m,"class","highlighter-rouge language-javascript"),f(w,"class","highlighter-rouge language-javascript"),f(y,"class","highlighter-rouge language-javascript"),f(j,"class","highlighter-rouge language-javascript"),f(v,"class","highlighter-rouge language-javascript"),f(_,"class","highlighter-rouge language-javascript"),f(k,"class","highlighter-rouge language-javascript")},m(s,e){n(s,i,e),n(s,r,e),n(s,c,e),n(s,h,e),n(s,o,e),n(s,p,e),n(s,u,e),n(s,F,e),n(s,b,e),n(s,Z,e),n(s,g,e),n(s,z,e),n(s,m,e),n(s,K,e),n(s,x,e),n(s,R,e),n(s,T,e),n(s,D,e),n(s,w,e),n(s,Q,e),n(s,A,e),n(s,U,e),n(s,H,e),n(s,V,e),n(s,M,e),n(s,X,e),n(s,L,e),n(s,Y,e),n(s,y,e),n(s,ss,e),n(s,C,e),n(s,es,e),n(s,S,e),n(s,ns,e),n(s,I,e),n(s,ts,e),n(s,j,e),n(s,as,e),n(s,P,e),n(s,ls,e),n(s,G,e),n(s,is,e),n(s,v,e),n(s,os,e),n(s,E,e),n(s,ps,e),n(s,$,e),n(s,rs,e),n(s,_,e),n(s,cs,e),n(s,q,e),n(s,hs,e),n(s,k,e),n(s,us,e),n(s,O,e),n(s,fs,e),n(s,W,e),n(s,ds,e),n(s,J,e),n(s,ms,e),n(s,N,e),n(s,ws,e),n(s,B,e)},p:Cs,d(s){s&&t(i),s&&t(r),s&&t(c),s&&t(h),s&&t(o),s&&t(p),s&&t(u),s&&t(F),s&&t(b),s&&t(Z),s&&t(g),s&&t(z),s&&t(m),s&&t(K),s&&t(x),s&&t(R),s&&t(T),s&&t(D),s&&t(w),s&&t(Q),s&&t(A),s&&t(U),s&&t(H),s&&t(V),s&&t(M),s&&t(X),s&&t(L),s&&t(Y),s&&t(y),s&&t(ss),s&&t(C),s&&t(es),s&&t(S),s&&t(ns),s&&t(I),s&&t(ts),s&&t(j),s&&t(as),s&&t(P),s&&t(ls),s&&t(G),s&&t(is),s&&t(v),s&&t(os),s&&t(E),s&&t(ps),s&&t($),s&&t(rs),s&&t(_),s&&t(cs),s&&t(q),s&&t(hs),s&&t(k),s&&t(us),s&&t(O),s&&t(fs),s&&t(W),s&&t(ds),s&&t(J),s&&t(ms),s&&t(N),s&&t(ws),s&&t(B)}}}function Ps(d){let i,r;const c=[d[0],js];let h={$$slots:{default:[Is]},$$scope:{ctx:d}};for(let o=0;o<c.length;o+=1)h=ys(h,c[o]);return i=new Ss({props:h}),{c(){xs(i.$$.fragment)},m(o,p){Ts(i,o,p),r=!0},p(o,[p]){const u=p&1?As(c,[p&1&&vs(o[0]),p&0&&vs(js)]):{};p&2&&(u.$$scope={dirty:p,ctx:o}),i.$set(u)},i(o){r||(Hs(i.$$.fragment,o),r=!0)},o(o){Ms(i.$$.fragment,o),r=!1},d(o){Ls(i,o)}}}const js={comments:!0,date:"2017-11-15T00:00:00Z",excerpt:"In this third post about generators we'll be implementing async/await for ES6 with the help of generators and Promises.",section:"blog",tags:["javascript","generators","es6","promises"],title:"Async/Await with Generators and Promises"};function Gs(d,i,r){return d.$$set=c=>{r(0,i=ys(ys({},i),_s(c)))},i=_s(i),[i]}class Es extends ks{constructor(i){super(),bs(this,i,Gs,Ps,gs,{})}}var Os=Object.freeze(Object.defineProperty({__proto__:null,default:Es,metadata:js},Symbol.toStringTag,{value:"Module"}));export{Es as A,Os as _,js as m};
