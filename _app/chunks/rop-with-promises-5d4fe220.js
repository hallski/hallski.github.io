import{S as ne,i as oe,s as ie,y as se,r as re,u as pe,v as ce,w as le,m as fe,k as he,x as ue,I as ae,e as a,g as n,a as ee,c as t,n as de,f as l}from"./index-0d9ad2d2.js";import{B as me}from"./blog-layout-f66b7ab1.js";function we(u){let o,p,c,f,i,r,h,P,w,$,y,R,_,E,j,A,k,J,v,B,b,G,g,U,T,W,x,q,d,z,H,N,m,V,L,Z,M,D,S,K,C,Q,F,X,I,Y,O;return{c(){o=a("p"),o.innerHTML='In the last post <a href="/blog/building-interactions-with-gcf">Building Interactions with GCF</a>, I focused on the implementation of the various interactions. This post will focus on the control flow and the use of Javascript <em>promises</em> to chain the operations together in a readable way.',p=n(),c=a("p"),c.textContent="To repeat, this is the resulting GCF event handler:",f=n(),i=a("div"),i.innerHTML=`<div class="highlight"><pre class="highlight"><code><span class="hljs-built_in">exports</span>.<span class="hljs-property">catFinder</span> = <span class="hljs-title function_">filteredEventHandler</span>(eventFilter, <span class="hljs-keyword">function</span> (<span class="hljs-params">event, callback</span>) {
	<span class="hljs-keyword">const</span> file = event.<span class="hljs-property">data</span>
	<span class="hljs-keyword">const</span> storageUri = <span class="hljs-string">\`gs://<span class="hljs-subst">\${file.bucket}</span>/<span class="hljs-subst">\${file.name}</span>\`</span>

	<span class="hljs-keyword">return</span> <span class="hljs-title function_">visionFetchLabels</span>(storageUri)
		.<span class="hljs-title function_">then</span>(<span class="hljs-title function_">any</span>(isCat))
		.<span class="hljs-title function_">then</span>(<span class="hljs-title function_">notifySlack</span>(secrets.<span class="hljs-property">slackWebhook</span>, <span class="hljs-string">\`A cat was posted: <span class="hljs-subst">\${storageUri}</span>\`</span>))
		.<span class="hljs-title function_">then</span>(logSuccess, logError)
		.<span class="hljs-title function_">then</span>(callback)
})</code></pre></div>`,r=n(),h=a("ol"),h.innerHTML=`<li>Fetch the labels through Vision API</li> 
<li>If any of the labels match a cat</li> 
<li>Send a notification to the Slack through an incoming webhook</li> 
<li>If all succeeded, log that. Otherwise log if there was an error.</li> 
<li>Finally, call the provided callback.</li>`,P=n(),w=a("p"),w.innerHTML='The code can be found on <a href="https://github.com/hallski/cat-finder" rel="nofollow">Github</a>',$=n(),y=a("h2"),y.textContent="Railway Oriented Programming (ROP)",R=n(),_=a("p"),_.innerHTML='The inspiration for this implementation was taken from an excellent talk by Scott Wlaschin about <a href="http://fsharpforfunandprofit.com/rop/" rel="nofollow">Railway Oriented Programming</a>. For a more in-depth description of ROP, I can highly recommend watching the talk and slides. The examples are in F# but shouldn\u2019t be a problem to follow even if you are new to the language.',E=n(),j=a("p"),j.innerHTML="In short, the idea is to describe the happy path through a process as the main <em>track</em> and if an error occurs, the flow is shifted over to a secondary <em>error track</em>. Once on the error track, the flow will stay there until delt with. This could either be by logging an error or by handling the error and shifting the flow back onto the main track.",A=n(),k=a("p"),k.textContent="To better illustrate what this means for the code above, here it is described as the two tracks.",J=n(),v=a("p"),v.innerHTML=`<img src="/images/posts/rop-catfinder.png" alt="Resulting App"/> 
<em>(Graphics comes from Scotts presentation).</em>`,B=n(),b=a("p"),b.innerHTML="The flow starts on the green (above) track and any of <code>visionFetchLabels</code>, <code>any(isCat)</code> and <code>notifySlack</code> can shift the flow over to the red (below) track. At the end, the <code>logSuccess</code> function is called in the green track and <code>logError</code> is called on the red track. After that, the tracks are again merged and <code>callback</code> is called.",G=n(),g=a("h2"),g.textContent="ROP with Javascript promises",U=n(),T=a("p"),T.innerHTML="Javascript promises lends themselves very well to this style of programming where a <code>resolve</code> keeps the flow on the happy track and a <code>reject</code> shifts flow to the error track.",W=n(),x=a("p"),x.innerHTML="This can best be seen in the implementation of <code>any</code>. It\u2019s a function that takes a <code>predicate</code> and returns a new function expecting an array of items. If the predicate is true for any of the items, a <em>resolved</em> promise is returned (stay on the happy track), otherwise a <em>rejected</em> promise is returned (move to error track).",q=n(),d=a("div"),d.innerHTML=`<div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">any</span>(<span class="hljs-params">predicate</span>) {
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">items</span>) {
		<span class="hljs-keyword">return</span> items.<span class="hljs-title function_">find</span>(predicate) ? <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(items) : <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>()
	}
}</code></pre></div>`,z=n(),H=a("p"),H.innerHTML="The image not containing a cat isn\u2019t really an error, which is why no error is passed in the rejection. The <code>logError</code> function checks if it gets an error and logs it if it does, otherwise does nothing.",N=n(),m=a("div"),m.innerHTML=`<div class="highlight"><pre class="highlight"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">logSuccess</span>(<span class="hljs-params"></span>) {
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">\`Successfully sent a cat to slack\`</span>)
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">logError</span>(<span class="hljs-params">error</span>) {
	<span class="hljs-keyword">if</span> (error) {
		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">\`Function failed with: <span class="hljs-subst">\${error.message}</span>\`</span>)
	}
}</code></pre></div>`,V=n(),L=a("p"),L.innerHTML="Finally, as neither <code>logSuccess</code> or <code>logError</code> returns a rejection, they will both be wrapped in a <code>resolve</code> and are both on the happy track again for finally calling <code>callback</code>.",Z=n(),M=a("h2"),M.textContent="Higher order functions and ROP",D=n(),S=a("p"),S.innerHTML="Both <code>any</code> and <code>notifySlack</code> are higher order functions (returns new functions). The reason for this is that the flow through the happy track only allows for passing one value on to the next function.",K=n(),C=a("p"),C.textContent="This is a very common scenario but might take some getting used to if you are comming from an OOP background, I know it did for me at least.",Q=n(),F=a("h2"),F.textContent="Extra nice in Javascript",X=n(),I=a("p"),I.innerHTML='This style of programming would work in any language with support for an <a href="https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell/10_Error_Handling#the-either-monad" rel="nofollow">Either type</a> and higher order functions.',Y=n(),O=a("p"),O.textContent="However, with promises you get an extra level of power since asynchronous operations can be modelled as well. With Javascript including promises out of the box, Node.js and third party frameworks all have great support for them and this style of programming can be a great option for a wide array of applications.",ee(i,"class","highlighter-rouge language-javascript"),ee(d,"class","highlighter-rouge language-javascript"),ee(m,"class","highlighter-rouge language-javascript")},m(e,s){t(e,o,s),t(e,p,s),t(e,c,s),t(e,f,s),t(e,i,s),t(e,r,s),t(e,h,s),t(e,P,s),t(e,w,s),t(e,$,s),t(e,y,s),t(e,R,s),t(e,_,s),t(e,E,s),t(e,j,s),t(e,A,s),t(e,k,s),t(e,J,s),t(e,v,s),t(e,B,s),t(e,b,s),t(e,G,s),t(e,g,s),t(e,U,s),t(e,T,s),t(e,W,s),t(e,x,s),t(e,q,s),t(e,d,s),t(e,z,s),t(e,H,s),t(e,N,s),t(e,m,s),t(e,V,s),t(e,L,s),t(e,Z,s),t(e,M,s),t(e,D,s),t(e,S,s),t(e,K,s),t(e,C,s),t(e,Q,s),t(e,F,s),t(e,X,s),t(e,I,s),t(e,Y,s),t(e,O,s)},p:de,d(e){e&&l(o),e&&l(p),e&&l(c),e&&l(f),e&&l(i),e&&l(r),e&&l(h),e&&l(P),e&&l(w),e&&l($),e&&l(y),e&&l(R),e&&l(_),e&&l(E),e&&l(j),e&&l(A),e&&l(k),e&&l(J),e&&l(v),e&&l(B),e&&l(b),e&&l(G),e&&l(g),e&&l(U),e&&l(T),e&&l(W),e&&l(x),e&&l(q),e&&l(d),e&&l(z),e&&l(H),e&&l(N),e&&l(m),e&&l(V),e&&l(L),e&&l(Z),e&&l(M),e&&l(D),e&&l(S),e&&l(K),e&&l(C),e&&l(Q),e&&l(F),e&&l(X),e&&l(I),e&&l(Y),e&&l(O)}}}function ye(u){let o,p;const c=[u[0],te];let f={$$slots:{default:[we]},$$scope:{ctx:u}};for(let i=0;i<c.length;i+=1)f=se(f,c[i]);return o=new me({props:f}),{c(){re(o.$$.fragment)},m(i,r){pe(o,i,r),p=!0},p(i,[r]){const h=r&1?ce(c,[r&1&&le(i[0]),r&0&&le(te)]):{};r&2&&(h.$$scope={dirty:r,ctx:i}),o.$set(h)},i(i){p||(fe(o.$$.fragment,i),p=!0)},o(i){he(o.$$.fragment,i),p=!1},d(i){ue(o,i)}}}const te={comments:!0,date:"2017-11-06T00:00:00Z",excerpt:null,section:"blog",tags:["javascript","promises","rop"],title:"Railway oriented programming with Promises"};function _e(u,o,p){return u.$$set=c=>{p(0,o=se(se({},o),ae(c)))},o=ae(o),[o]}class je extends ne{constructor(o){super(),oe(this,o,_e,ye,ie,{})}}var be=Object.freeze(Object.defineProperty({__proto__:null,default:je,metadata:te},Symbol.toStringTag,{value:"Module"}));export{je as R,be as _,te as m};
